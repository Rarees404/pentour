<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8" />
    <title>Secure Chat ‚Ä¢ Live</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Fonts & FontAwesome -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" />

    <style>
        :root {
            --bg-primary: #0a0a1f;
            --bg-secondary: #121229;
            --accent-cyan: #00e5ff;
            --accent-magenta: #ff0080;
            --text-main: #e0e0ff;
            --text-secondary: #8888aa;
            --timestamp-text: #999;
            --glow-small: 0 0 6px var(--accent-cyan);
            --transition: 0.2s ease;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: var(--bg-primary);
            font-family: 'Orbitron', sans-serif;
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* ‚Äî‚Äî‚Äî Waiting Overlay ‚Äî‚Äî‚Äî */
        #waitingOverlay {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        #waitingOverlay .box {
            background: #121229;
            padding: 2rem 3rem;
            border-radius: 8px;
            text-align: center;
            box-shadow: var(--glow-small);
        }
        #waitingOverlay .box p {
            color: var(--text-main);
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }
        #waitingOverlay .box small {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* ‚Äî‚Äî‚Äî Header / Title Bar ‚Äî‚Äî‚Äî */
        header#chat-header {
            background: var(--bg-secondary);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--glow-small);
            border-bottom: 2px solid var(--accent-cyan);
            z-index: 10;
        }
        .chat-title {
            font-size: 1.4rem;
            color: var(--accent-cyan);
            text-shadow: var(--glow-small);
            display: flex;
            align-items: center;
        }
        .chat-title i { margin-right: 0.5rem; }
        .account-btn {
            background: transparent;
            border: 1px solid var(--accent-cyan);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            color: var(--accent-cyan);
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            text-decoration: none;
            transition: var(--transition);
        }
        .account-btn i { margin-right: 0.4rem; }
        .account-btn:hover { background: rgba(0,229,255,0.1); }

        /* ‚Äî‚Äî‚Äî Main Chat Container ‚Äî‚Äî‚Äî */
        #chatContainer {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 68px);
        }

        /* Messages list */
        #messages {
            flex: 1;
            padding: 1.5rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        /* Message bubbles */
        .message {
            max-width: 75%;
            padding: 0.75rem 1rem;
            border-radius: 12px;
            font-size: 0.95rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            row-gap: 0.5rem;
            word-wrap: break-word;
        }

        /* Sent messages (current user) */
        .sent {
            align-self: flex-end;
            background: var(--accent-cyan);
            color: #000;
            border-bottom-right-radius: 4px;
            max-width: 75%;
            padding: 0.75rem 1rem;
            border-radius: 12px;
            font-size: 0.95rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            margin-bottom: 0.5rem;
            word-wrap: break-word;
        }

        /* Received messages (other user) */
        .received {
            align-self: flex-start;
            background: var(--bg-secondary);
            color: var(--text-main);
            border-bottom-left-radius: 4px;
            max-width: 75%;
            padding: 0.75rem 1rem;
            border-radius: 12px;
            font-size: 0.95rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            margin-bottom: 0.5rem;
            word-wrap: break-word;
        }

        .message-username {
            font-weight: bold;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        .message-time {
            font-size: 0.7rem;
            color: var(--timestamp-text);
            text-align: right;
        }

        /* Input Area */
        #message-form {
            display: flex;
            padding: 1rem;
            background: var(--bg-secondary);
            border-top: 2px solid var(--accent-cyan);
        }
        #message-input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 1px solid var(--accent-cyan);
            border-radius: 50px;
            background: var(--bg-primary);
            color: var(--text-main);
            font-size: 1rem;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            transition: var(--transition);
        }
        #message-input:focus { outline: none; border-color: var(--accent-magenta); }
        #message-form button {
            margin-left: 0.75rem;
            background: var(--accent-magenta);
            border-radius: 50px;
            padding: 0 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: var(--glow-small);
            transition: var(--transition);
            color: #000;
            border: none;
        }
        #message-form button:hover { transform: scale(1.05); }

        /* Leave Chat */
        #leave-chat {
            width: 100%;
            padding: 0.9rem;
            background: #ff0044;
            border: none;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: var(--transition);
            cursor: pointer;
        }
        #leave-chat:hover { background: #e6003d; }

        /* Loading indicator */
        .loading {
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            padding: 1rem;
        }

        /* Error message styling */
        .error-message {
            background: rgba(255, 0, 68, 0.1);
            border: 1px solid #ff0044;
            color: #ff6b6b;
            padding: 0.75rem;
            border-radius: 8px;
            margin: 0.5rem;
            text-align: center;
        }
    </style>
</head>

<body>
<div id="waitingOverlay">
    <div class="box">
        <p>Waiting for the other user to join‚Ä¶</p>
        <small>(This window will close once they arrive.)</small>
    </div>
</div>

<!-- ‚Äî‚Äî‚Äî Header Bar ‚Äî‚Äî‚Äî -->
<header id="chat-header">
    <div class="chat-title">
        <i class="fas fa-comments"></i>
        Chat with <span id="partner-name">‚Ä¶</span>
    </div>
    <a href="/chat/usermenu/" class="account-btn">
        <i class="fas fa-user-circle"></i> Account
    </a>
</header>

<!-- ‚Äî‚Äî‚Äî Main Chat Container ‚Äî‚Äî‚Äî -->
<div id="chatContainer" style="display: none;">
    <!-- Message list -->
    <div id="messages"></div>

    <!-- Message input form -->
    <form id="message-form">
        <input type="text" id="message-input" placeholder="Type your message..." required />
        <button type="submit">Send <i class="fas fa-paper-plane"></i></button>
    </form>

    <!-- Leave button -->
    <button id="leave-chat"><i class="fas fa-sign-out-alt"></i> Leave Chat</button>
</div>

<script>
    (async function() {
        const STORAGE_PRIV = "private_key_pem";
        const STORAGE_PUB = "public_key_pem";
        const uploadEndpoint = "/chat/upload-public-key/";

        // Utility functions
        function derToPem(derBuffer, label) {
            const bytes = new Uint8Array(derBuffer);
            let b64 = "";
            for (let i = 0; i < bytes.byteLength; i++) {
                b64 += String.fromCharCode(bytes[i]);
            }
            const b64lines = window.btoa(b64).match(/.{1,64}/g).join("\n");
            return `-----BEGIN ${label}-----\n${b64lines}\n-----END ${label}-----`;
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = "";
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        function base64ToArrayBuffer(b64) {
            const binary = window.atob(b64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        async function importRsaPublicKeyForEncrypt(pem) {
            const b64 = pem.replace(/-----.*?-----/g, "").replace(/\s+/g, "");
            const der = Uint8Array.from(window.atob(b64), c => c.charCodeAt(0)).buffer;
            return await window.crypto.subtle.importKey(
                "spki",
                der,
                { name: "RSA-OAEP", hash: "SHA-256" },
                true,
                ["encrypt"]
            );
        }

        async function importRsaPrivateKey(pem) {
            const b64 = pem.replace(/-----.*?-----/g, "").replace(/\s+/g, "");
            const der = Uint8Array.from(window.atob(b64), c => c.charCodeAt(0)).buffer;
            return await window.crypto.subtle.importKey(
                "pkcs8",
                der,
                { name: "RSA-OAEP", hash: "SHA-256" },
                true,
                ["decrypt"]
            );
        }

        async function importRsaPublicKeyForVerify(pem) {
            const b64 = pem.replace(/-----.*?-----/g, "").replace(/\s+/g, "");
            const der = Uint8Array.from(window.atob(b64), c => c.charCodeAt(0)).buffer;
            return await window.crypto.subtle.importKey(
                "spki",
                der,
                { name: "RSA-PSS", hash: "SHA-256" },
                true,
                ["verify"]
            );
        }

        // Key management functions
        async function loadPublicKeyOfOtherUser() {
            const partnerId = localStorage.getItem("partner_id");
            const token = localStorage.getItem("token");

            if (!partnerId || !token) {
                throw new Error("Missing partner ID or token");
            }

            const response = await fetch("/chat/get-public-key/" + partnerId + "/", {
                headers: { "Authorization": "Token " + token }
            });

            if (!response.ok) throw new Error("Could not fetch partner public key.");

            const partnerPubPem = await response.text();
            localStorage.setItem("partner_public_key", partnerPubPem);
            return partnerPubPem;
        }

        async function retrieveOwnPrivateKey() {
            const privateKeyPem = localStorage.getItem(STORAGE_PRIV);
            if (!privateKeyPem) throw new Error("Private key not found.");
            return await importRsaPrivateKey(privateKeyPem);
        }

        // Initialize RSA key pair if not exists
        let privPem = localStorage.getItem(STORAGE_PRIV);
        if (!privPem) {
            try {
                const keyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "RSA-PSS",
                        modulusLength: 2048,
                        publicExponent: new Uint8Array([1, 0, 1]),
                        hash: "SHA-256"
                    },
                    true,
                    ["sign", "verify"]
                );

                // Generate separate key pair for encryption
                const encKeyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "RSA-OAEP",
                        modulusLength: 2048,
                        publicExponent: new Uint8Array([1, 0, 1]),
                        hash: "SHA-256"
                    },
                    true,
                    ["encrypt", "decrypt"]
                );

                const privDer = await window.crypto.subtle.exportKey("pkcs8", encKeyPair.privateKey);
                privPem = derToPem(privDer, "PRIVATE KEY");
                localStorage.setItem(STORAGE_PRIV, privPem);

                const pubDer = await window.crypto.subtle.exportKey("spki", encKeyPair.publicKey);
                const pubPem = derToPem(pubDer, "PUBLIC KEY");
                localStorage.setItem(STORAGE_PUB, pubPem);

                const resp = await fetch(uploadEndpoint, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Token " + localStorage.getItem("token")
                    },
                    body: JSON.stringify({ public_key: pubPem })
                });
                if (!resp.ok) console.warn("Could not upload public key:", await resp.text());
            } catch (err) {
                console.error("Error generating RSA key pair:", err);
                showError("Failed to generate encryption keys");
            }
        }

        // DOM elements
        const messagesDiv = document.getElementById("messages");
        const partnerNameSpan = document.getElementById("partner-name");
        const messageForm = document.getElementById("message-form");
        const messageInput = document.getElementById("message-input");
        const waitingOverlay = document.getElementById("waitingOverlay");
        const chatContainer = document.getElementById("chatContainer");
        const leaveButton = document.getElementById("leave-chat");

        // Chat variables
        const chatId = localStorage.getItem("chat_id");
        const token = localStorage.getItem("token");
        let partnerUsername = localStorage.getItem("partner") || "‚Ä¶";
        let pollInterval = null;

        // Error handling
        function showError(message) {
            const errorDiv = document.createElement("div");
            errorDiv.className = "error-message";
            errorDiv.textContent = message;
            messagesDiv.appendChild(errorDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Initialize UI
        partnerNameSpan.textContent = partnerUsername;

        // Chat functions
        async function startChat() {
            if (!chatId || !token) {
                alert("Missing chat ID or authentication token.");
                window.location.href = "/";
                return;
            }

            try {
                const joinResp = await fetch("/chat/join-chat/", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Token " + token
                    },
                    body: JSON.stringify({ chat_id: chatId })
                });

                if (!joinResp.ok) {
                    const errJson = await joinResp.json().catch(() => ({}));
                    alert(errJson.message || "Failed to join chat.");
                    window.location.href = "/";
                    return;
                }
            } catch (err) {
                console.error("Join-chat error:", err);
                alert("Network error while joining chat.");
                window.location.href = "/";
                return;
            }

            pollInterval = setInterval(checkChatReady, 2000);
            await checkChatReady();
        }

        async function checkChatReady() {
            const resp = await fetch(`/chat/get-messages/${chatId}/`, {
                method: "GET",
                headers: {
                    "Authorization": "Token " + localStorage.getItem("token"),
                }
            });

            if (resp.status === 200) {
                const data = await resp.json();

                if (data.both_joined) {
                    // 1) Hide the overlay and show chat right away
                    waitingOverlay.style.display = "none";
                    chatContainer.style.display = "flex";

                    // 2) Store partner_id so send‚Äêmessage can use it
                    if (data.partner_id) {
                        localStorage.setItem("partner_id", data.partner_id);
                    }

                    // 3) Then attempt to load encryption keys (errors won‚Äôt block UI)
                    try {
                        await loadPublicKeyOfOtherUser();
                        await retrieveOwnPrivateKey();
                    } catch (err) {
                        console.warn("Key error (UI already shown):", err);
                        showError("Failed to load encryption keys (messages may be unencrypted).");
                    }

                    // 4) Update partner‚Äôs name if needed
                    if (data.partner && data.partner !== partnerUsername) {
                        partnerUsername = data.partner;
                        partnerNameSpan.textContent = partnerUsername;
                        localStorage.setItem("partner", partnerUsername);
                    }

                    // 5) Render any existing messages
                    await renderMessages(data.messages, data.current_user);

                    // 6) Switch to polling only for new messages from now on
                    clearInterval(pollInterval);
                    pollInterval = setInterval(fetchNewMessages, 2000);
                }
            } else {
                console.error("checkChatReady() failed with status:", resp.status);
            }
        }

        async function fetchNewMessages() {
            try {
                const resp = await fetch("/chat/get-messages/" + chatId + "/", {
                    headers: { "Authorization": "Token " + token }
                });
                if (!resp.ok) return;

                const data = await resp.json();

                if (data.partner && data.partner !== partnerUsername) {
                    partnerUsername = data.partner;
                    partnerNameSpan.textContent = partnerUsername;
                    localStorage.setItem("partner", partnerUsername);
                }

                await renderMessages(data.messages, data.current_user);
            } catch (err) {
                console.error("Error fetching new messages:", err);
            }
        }

        async function renderMessages(messages, currentUserUsername) {
            messagesDiv.innerHTML = "";

            for (const msg of messages) {
                await renderEncryptedMessage(msg, currentUserUsername);
            }

            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        async function renderEncryptedMessage(msg, currentUserUsername) {
            const isCurrentUser = (msg.sender_username === currentUserUsername);

            try {
                const privPemLocal = localStorage.getItem("private_key_pem");
                if (!privPemLocal) {
                    showError("Private key missing");
                    return;
                }

                const myPrivKey = await importRsaPrivateKey(privPemLocal);
                const encryptedArrayBuffer = base64ToArrayBuffer(msg.encrypted_text);

                let decryptedText;
                try {
                    const decryptedArrayBuffer = await window.crypto.subtle.decrypt(
                        { name: "RSA-OAEP" },
                        myPrivKey,
                        encryptedArrayBuffer
                    );
                    decryptedText = new TextDecoder().decode(decryptedArrayBuffer);
                } catch (decryptError) {
                    console.error("Decryption failed:", decryptError);
                    decryptedText = "üîê Unable to decrypt message";
                }

                // Verify signature if available
                let signatureStatus = "";
                if (msg.signature && msg.sender_public_key) {
                    try {
                        const senderPubKey = await importRsaPublicKeyForVerify(msg.sender_public_key);
                        const signatureBuffer = base64ToArrayBuffer(msg.signature);

                        const isValidSignature = await window.crypto.subtle.verify(
                            { name: "RSA-PSS", saltLength: 32 },
                            senderPubKey,
                            signatureBuffer,
                            new TextEncoder().encode(decryptedText)
                        );

                        signatureStatus = isValidSignature ? " ‚úì" : " ‚ö†!!!!";
                    } catch (verifyError) {
                        console.error("Signature verification failed:", verifyError);
                        signatureStatus = " ??????";
                    }
                }

                const div = document.createElement("div");
                div.className = isCurrentUser ? "sent" : "received";

                const messageText = `${msg.sender_username}: ${decryptedText}${signatureStatus}`;
                div.textContent = messageText;

                messagesDiv.appendChild(div);
            } catch (renderError) {
                console.error("Error rendering message:", renderError);
                showError("Failed to render message");
            }
        }

        // ‚îÄ‚îÄ‚îÄ Single ‚Äúsubmit‚Äù listener below ‚îÄ‚îÄ‚îÄ

        messageForm.addEventListener("submit", async function(e) {
            e.preventDefault();
            const plaintext = messageInput.value.trim();
            if (!plaintext) return;

            try {
                // 1) Load our own private key (stored in localStorage)
                const privPemLocal = localStorage.getItem("private_key_pem");
                if (!privPemLocal) {
                    showError("Private key missing");
                    return;
                }
                const myPrivKey = await importRsaPrivateKey(privPemLocal);

                // 2) Get partner_id (must have been saved by checkChatReady)
                const partnerId = localStorage.getItem("partner_id");
                if (!partnerId) {
                    showError("Partner ID missing");
                    return;
                }

                // 3) Fetch partner‚Äôs public key from server
                const respPub = await fetch("/chat/get-public-key/" + partnerId + "/", {
                    headers: { "Authorization": "Token " + token }
                });
                if (!respPub.ok) {
                    showError("Failed to get partner's public key");
                    return;
                }
                const partnerPubPem = await respPub.text();
                const partnerPubKey = await importRsaPublicKeyForEncrypt(partnerPubPem);

                // 4) Encrypt the plaintext
                const encryptedArrayBuffer = await window.crypto.subtle.encrypt(
                    { name: "RSA-OAEP" },
                    partnerPubKey,
                    new TextEncoder().encode(plaintext)
                );

                // 5) Sign the plaintext (using RSA-PSS)
                const signingKeyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "RSA-PSS",
                        modulusLength: 2048,
                        publicExponent: new Uint8Array([1, 0, 1]),
                        hash: "SHA-256"
                    },
                    true,
                    ["sign"]
                );
                const signatureBuffer = await window.crypto.subtle.sign(
                    { name: "RSA-PSS", saltLength: 32 },
                    signingKeyPair.privateKey,
                    new TextEncoder().encode(plaintext)
                );

                // 6) Base64‚Äêencode both ciphertext and signature
                const encryptedB64 = arrayBufferToBase64(encryptedArrayBuffer);
                const sigB64       = arrayBufferToBase64(signatureBuffer);

                // 7) POST to /chat/send-message/{chatId}/
                const sendResp = await fetch("/chat/send-message/" + chatId + "/", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Token " + token
                    },
                    body: JSON.stringify({
                        encrypted_text: encryptedB64,
                        signature:      sigB64
                    })
                });

                if (!sendResp.ok) {
                    showError("Failed to send message");
                    return;
                }

                // 8) Clear input on success
                messageInput.value = "";
            } catch (sendError) {
                console.error("Send message error:", sendError);
                showError("Failed to send message");
            }
        });

        // Leave chat functionality
        leaveButton.addEventListener("click", async function() {
            if (confirm("Are you sure you want to leave this chat?")) {
                await leaveChat();
            }
        });

        async function leaveChat() {
            try {
                await fetch("/chat/leave-chat/" + chatId + "/", {
                    method: "POST",
                    headers: { "Authorization": "Token " + token }
                });
            } catch (err) {
                console.error("Error leaving chat:", err);
            } finally {
                clearInterval(pollInterval);
                window.location.href = "/";
            }
        }

        // Handle page unload
        window.addEventListener("beforeunload", async function() {
            if (pollInterval) {
                clearInterval(pollInterval);
            }
            try {
                await fetch("/chat/leave-chat/" + chatId + "/", {
                    method: "POST",
                    headers: { "Authorization": "Token " + token }
                });
            } catch (err) {
                console.error("Error on page unload:", err);
            }
        });

        // Start the chat application
        startChat();
    })();
</script>
</body>
</html>
