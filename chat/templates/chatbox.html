<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8" />
    <title>Secure Chat • Live</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" />

    <style>
        :root {
            --bg-primary: #0a0a1f;
            --bg-secondary: #121229;
            --accent-cyan: #00e5ff;
            --accent-magenta: #ff0080;
            --text-main: #e0e0ff;
            --text-secondary: #8888aa;
            --timestamp-text: #999;
            --glow-small: 0 0 6px var(--accent-cyan);
            --transition: 0.2s ease;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: var(--bg-primary);
            font-family: 'Orbitron', sans-serif;
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* ——— Waiting Overlay ——— */
        #waitingOverlay {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        #waitingOverlay .box {
            background: #121229;
            padding: 2rem 3rem;
            border-radius: 8px;
            text-align: center;
            box-shadow: var(--glow-small);
        }
        #waitingOverlay .box p {
            color: var(--text-main);
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }
        #waitingOverlay .box small {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* ——— Header / Title Bar ——— */
        header#chat-header {
            background: var(--bg-secondary);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--glow-small);
            border-bottom: 2px solid var(--accent-cyan);
            z-index: 10;
        }
        .chat-title {
            font-size: 1.4rem;
            color: var(--accent-cyan);
            text-shadow: var(--glow-small);
            display: flex;
            align-items: center;
        }
        .chat-title i { margin-right: 0.5rem; }
        .account-btn {
            background: transparent;
            border: 1px solid var(--accent-cyan);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            color: var(--accent-cyan);
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            text-decoration: none;
            transition: var(--transition);
        }
        .account-btn i { margin-right: 0.4rem; }
        .account-btn:hover { background: rgba(0,229,255,0.1); }

        /* ——— Main Chat Container ——— */
        #chatContainer {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 68px);
        }

        /* Messages list */
        #messages {
            flex: 1;
            padding: 1.5rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        /* Message bubbles */
        .message {
            max-width: 75%;
            padding: 0.75rem 1rem;
            border-radius: 12px;
            font-size: 0.95rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            row-gap: 0.5rem;
            word-wrap: break-word;
        }

        /* Sent messages (current user) */
        .sent {
            align-self: flex-end;
            background: var(--accent-cyan);
            color: #000;
            border-bottom-right-radius: 4px;
            max-width: 75%;
            padding: 0.75rem 1rem;
            border-radius: 12px;
            font-size: 0.95rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            margin-bottom: 0.5rem;
            word-wrap: break-word;
        }

        /* Received messages (other user) */
        .received {
            align-self: flex-start;
            background: var(--bg-secondary);
            color: var(--text-main);
            border-bottom-left-radius: 4px;
            max-width: 75%;
            padding: 0.75rem 1rem;
            border-radius: 12px;
            font-size: 0.95rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            margin-bottom: 0.5rem;
            word-wrap: break-word;
        }

        .message-username {
            font-weight: bold;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        .message-time {
            font-size: 0.7rem;
            color: var(--timestamp-text);
            text-align: right;
        }

        /* Input Area */
        #message-form {
            display: flex;
            padding: 1rem;
            background: var(--bg-secondary);
            border-top: 2px solid var(--accent-cyan);
        }
        #message-input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 1px solid var(--accent-cyan);
            border-radius: 50px;
            background: var(--bg-primary);
            color: var(--text-main);
            font-size: 1rem;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            transition: var(--transition);
        }
        #message-input:focus { outline: none; border-color: var(--accent-magenta); }
        #message-form button {
            margin-left: 0.75rem;
            background: var(--accent-magenta);
            border-radius: 50px;
            padding: 0 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: var(--glow-small);
            transition: var(--transition);
            color: #000;
            border: none;
        }
        #message-form button:hover { transform: scale(1.05); }

        /* Leave Chat */
        #leave-chat {
            width: 100%;
            padding: 0.9rem;
            background: #ff0044;
            border: none;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: var(--transition);
            cursor: pointer;
        }
        #leave-chat:hover { background: #e6003d; }

        /* Loading indicator */
        .loading {
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            padding: 1rem;
        }

        /* Error message styling */
        .error-message {
            background: rgba(255, 0, 68, 0.1);
            border: 1px solid #ff0044;
            color: #ff6b6b;
            padding: 0.75rem;
            border-radius: 8px;
            margin: 0.5rem;
            text-align: center;
        }
    </style>
</head>

<body>
<div id="waitingOverlay">
    <div class="box">
        <p>Waiting for the other user to join…</p>
        <small>(This window will close once they arrive.)</small>
    </div>
</div>

<header id="chat-header">
    <div class="chat-title">
        <i class="fas fa-comments"></i>
        Chat with <span id="partner-name">…</span>
    </div>
    <a href="/chat/usermenu/" class="account-btn">
        <i class="fas fa-user-circle"></i> Account
    </a>
</header>

<div id="chatContainer" style="display: none;">
    <div id="messages"></div>

    <form id="message-form">
        <input type="text" id="message-input" placeholder="Type your message..." required />
        <button type="submit">Send <i class="fas fa-paper-plane"></i></button>
    </form>

    <button id="leave-chat"><i class="fas fa-sign-out-alt"></i> Leave Chat</button>
</div>

<script>
    (async function() {
        // Local Storage Keys
        const STORAGE_PRIV = "private_key_pem"; // RSA-OAEP private key for decryption
        const STORAGE_PUB = "public_key_pem";   // RSA-OAEP public key for encryption by others
        const STORAGE_SIGN_PRIV = "signing_private_key_pem"; // RSA-PSS private key for signing
        const STORAGE_SIGN_PUB = "signing_public_key_pem"; // RSA-PSS public key for signature verification by others

        const uploadEndpoint = "/chat/upload-public-key/"; // Endpoint for uploading RSA-OAEP public key

        // --- Utility functions for ArrayBuffer <-> Base64 <-> PEM conversions ---
        function derToPem(derBuffer, label) {
            const bytes = new Uint8Array(derBuffer);
            let b64 = "";
            for (let i = 0; i < bytes.byteLength; i++) {
                b64 += String.fromCharCode(bytes[i]);
            }
            const b64lines = window.btoa(b64).match(/.{1,64}/g).join("\n");
            return `-----BEGIN ${label}-----\n${b64lines}\n-----END ${label}-----`;
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = "";
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        function base64ToArrayBuffer(b64) {
            const binary = window.atob(b64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // --- Cryptographic Helper Functions ---

        // Generate AES key (for symmetric encryption of messages)
        function generateAESKey() {
            return window.crypto.getRandomValues(new Uint8Array(32)); // AES-256 key
        }

        // AES-GCM encryption
        async function encryptWithAES(key, plaintext) {
            const iv = window.crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV recommended for AES-GCM
            const algorithm = { name: 'AES-GCM', iv: iv };

            const cryptoKey = await window.crypto.subtle.importKey(
                'raw',
                key,
                { name: 'AES-GCM' },
                false, // not extractable
                ['encrypt']
            );

            const encrypted = await window.crypto.subtle.encrypt(
                algorithm,
                cryptoKey,
                new TextEncoder().encode(plaintext)
            );

            // AES-GCM encrypted output is ciphertext + authentication tag.
            // The tag is usually the last 16 bytes.
            const ciphertext = encrypted.slice(0, encrypted.byteLength - 16);
            const tag = encrypted.slice(encrypted.byteLength - 16);

            return {
                ciphertext: arrayBufferToBase64(ciphertext),
                nonce: arrayBufferToBase64(iv),
                tag: arrayBufferToBase64(tag)
            };
        }

        // AES-GCM decryption
        async function decryptWithAES(key, data) {
            const ciphertext = base64ToArrayBuffer(data.ciphertext);
            const nonce = base64ToArrayBuffer(data.nonce);
            const tag = base64ToArrayBuffer(data.tag);

            // Combine ciphertext and tag for decryption
            const combined = new Uint8Array(ciphertext.byteLength + tag.byteLength);
            combined.set(new Uint8Array(ciphertext));
            combined.set(new Uint8Array(tag), ciphertext.byteLength);

            const algorithm = { name: 'AES-GCM', iv: nonce };

            const cryptoKey = await window.crypto.subtle.importKey(
                'raw',
                key,
                { name: 'AES-GCM' },
                false, // not extractable
                ['decrypt']
            );

            const decrypted = await window.crypto.subtle.decrypt(
                algorithm,
                cryptoKey,
                combined
            );

            return new TextDecoder().decode(decrypted);
        }

        // Import RSA Public Key for Encryption (OAEP)
        async function importRsaPublicKeyForEncrypt(pem) {
            const b64 = pem.replace(/-----.*?-----|[\n\r]/g, ""); // Remove PEM headers and newlines
            const der = Uint8Array.from(window.atob(b64), c => c.charCodeAt(0)).buffer;
            return await window.crypto.subtle.importKey(
                "spki", // SubjectPublicKeyInfo format
                der,
                { name: "RSA-OAEP", hash: "SHA-256" },
                true, // extractable
                ["encrypt"]
            );
        }

        // Import RSA Private Key for Decryption (OAEP)
        async function importRsaPrivateKeyForDecrypt(pem) {
            const b64 = pem.replace(/-----.*?-----|[\n\r]/g, "");
            const der = Uint8Array.from(window.atob(b64), c => c.charCodeAt(0)).buffer;
            return await window.crypto.subtle.importKey(
                "pkcs8", // PrivateKeyInfo format
                der,
                { name: "RSA-OAEP", hash: "SHA-256" },
                true, // extractable
                ["decrypt"]
            );
        }

        // Import RSA Private Key for Signing (PSS)
        async function importRsaPrivateKeyForSign(pem) {
            const b64 = pem.replace(/-----.*?-----|[\n\r]/g, "");
            const der = Uint8Array.from(window.atob(b64), c => c.charCodeAt(0)).buffer;
            return await window.crypto.subtle.importKey(
                "pkcs8", // PrivateKeyInfo format
                der,
                { name: "RSA-PSS", hash: "SHA-256" },
                true, // extractable
                ["sign"]
            );
        }

        // Import RSA Public Key for Verification (PSS)
        async function importRsaPublicKeyForVerify(pem) {
            const b64 = pem.replace(/-----.*?-----|[\n\r]/g, "");
            const der = Uint8Array.from(window.atob(b64), c => c.charCodeAt(0)).buffer;
            return await window.crypto.subtle.importKey(
                "spki", // SubjectPublicKeyInfo format
                der,
                { name: "RSA-PSS", hash: "SHA-256" },
                true, // extractable
                ["verify"]
            );
        }

        // --- Key Management and Generation ---
        let myEncryptionKeys; // Will store imported RSA-OAEP keys
        let mySigningKeys;    // Will store imported RSA-PSS keys
        let partnerPublicKey; // Will store imported partner's RSA-OAEP public key

        async function loadAndGenerateKeys() {
            let privPem = localStorage.getItem(STORAGE_PRIV);
            let pubPem = localStorage.getItem(STORAGE_PUB);
            let signPrivPem = localStorage.getItem(STORAGE_SIGN_PRIV);
            let signPubPem = localStorage.getItem(STORAGE_SIGN_PUB);

            // If any critical key is missing, generate all new pairs
            if (!privPem || !pubPem || !signPrivPem || !signPubPem) {
                console.log("Generating new RSA key pairs...");
                try {
                    // RSA-OAEP Key Pair (for Encryption/Decryption of AES key)
                    const encKeyPair = await window.crypto.subtle.generateKey(
                        {
                            name: "RSA-OAEP",
                            modulusLength: 2048,
                            publicExponent: new Uint8Array([1, 0, 1]), // 65537
                            hash: "SHA-256"
                        },
                        true, // extractable
                        ["encrypt", "decrypt"]
                    );
                    const encPrivDer = await window.crypto.subtle.exportKey("pkcs8", encKeyPair.privateKey);
                    privPem = derToPem(encPrivDer, "PRIVATE KEY");
                    localStorage.setItem(STORAGE_PRIV, privPem);
                    const encPubDer = await window.crypto.subtle.exportKey("spki", encKeyPair.publicKey);
                    pubPem = derToPem(encPubDer, "PUBLIC KEY");
                    localStorage.setItem(STORAGE_PUB, pubPem);
                    myEncryptionKeys = { privateKey: encKeyPair.privateKey, publicKey: encKeyPair.publicKey };

                    // RSA-PSS Key Pair (for Digital Signatures)
                    const signKeyPair = await window.crypto.subtle.generateKey(
                        {
                            name: "RSA-PSS",
                            modulusLength: 2048,
                            publicExponent: new Uint8Array([1, 0, 1]), // 65537
                            hash: "SHA-256"
                        },
                        true, // extractable
                        ["sign", "verify"]
                    );
                    const signPrivDer = await window.crypto.subtle.exportKey("pkcs8", signKeyPair.privateKey);
                    signPrivPem = derToPem(signPrivDer, "PRIVATE KEY");
                    localStorage.setItem(STORAGE_SIGN_PRIV, signPrivPem);
                    const signPubDer = await window.crypto.subtle.exportKey("spki", signKeyPair.publicKey);
                    signPubPem = derToPem(signPubDer, "PUBLIC KEY");
                    localStorage.setItem(STORAGE_SIGN_PUB, signPubPem);
                    mySigningKeys = { privateKey: signKeyPair.privateKey, publicKey: signKeyPair.publicKey };

                    // Upload the RSA-OAEP public key to the server
                    const token = localStorage.getItem("token");
                    if (token) {
                        const resp = await fetch(uploadEndpoint, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "Authorization": "Token " + token
                            },
                            body: JSON.stringify({ public_key: pubPem })
                        });
                        if (!resp.ok) {
                            console.warn("Could not upload public key:", await resp.text());
                            showError("Failed to upload encryption public key.");
                        } else {
                            console.log("RSA-OAEP Public key uploaded successfully.");
                        }
                    } else {
                        console.warn("No token found, cannot upload public key.");
                    }

                } catch (err) {
                    console.error("Error generating RSA key pairs:", err);
                    showError("Failed to generate encryption keys.");
                    throw err; // Re-throw to stop chat initialization if keys are essential
                }
            } else {
                console.log("Loading existing RSA key pairs...");
                // Import existing keys
                try {
                    myEncryptionKeys = {
                        privateKey: await importRsaPrivateKeyForDecrypt(privPem),
                        publicKey: await importRsaPublicKeyForEncrypt(pubPem)
                    };
                    mySigningKeys = {
                        privateKey: await importRsaPrivateKeyForSign(signPrivPem),
                        publicKey: await importRsaPublicKeyForVerify(signPubPem)
                    };
                } catch (err) {
                    console.error("Error importing stored RSA key pairs:", err);
                    showError("Failed to load encryption keys (messages may be unencrypted). Please clear local storage and try again.");
                    throw err; // Re-throw to signify a problem
                }
            }
        }

        async function loadPartnerPublicKey() {
            const partnerId = localStorage.getItem("partner_id");
            const token = localStorage.getItem("token");

            if (!partnerId || !token) {
                console.warn("Missing partner ID or token for public key fetch.");
                return null;
            }

            try {
                const response = await fetch(`/chat/get-public-key/${partnerId}/?_=${new Date().getTime()}`, {
                });

                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${await response.text()}`);
                }

                const partnerPubPem = await response.text();
                // Store for future use, though not strictly necessary if always fetching
                localStorage.setItem("partner_public_key", partnerPubPem);
                partnerPublicKey = await importRsaPublicKeyForEncrypt(partnerPubPem);
                console.log("Partner's public key loaded.");
                return partnerPublicKey;
            } catch (err) {
                console.error("Error fetching or importing partner public key:", err);
                showError("Failed to load partner's public key. Cannot send encrypted messages.");
                return null;
            }
        }

        // --- DOM Elements ---
        const messagesDiv = document.getElementById("messages");
        const partnerNameSpan = document.getElementById("partner-name");
        const messageForm = document.getElementById("message-form");
        const messageInput = document.getElementById("message-input");
        const waitingOverlay = document.getElementById("waitingOverlay");
        const chatContainer = document.getElementById("chatContainer");
        const leaveButton = document.getElementById("leave-chat");

        // --- Chat Variables ---
        const chatId = localStorage.getItem("chat_id");
        const token = localStorage.getItem("token");
        let partnerUsername = localStorage.getItem("partner") || "…";
        let pollInterval = null;

        // --- UI Functions ---
        function showError(message) {
            const errorDiv = document.createElement("div");
            errorDiv.className = "error-message";
            errorDiv.textContent = message;
            messagesDiv.appendChild(errorDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // --- Main Chat Logic ---
        async function startChat() {
            if (!chatId || !token) {
                alert("Missing chat ID or authentication token. Redirecting to home.");
                window.location.href = "/";
                return;
            }

            try {
                await loadAndGenerateKeys(); // Load or generate our own keys first
            } catch (e) {
                // Key generation/load failed, user is already alerted by showError
                console.error("Critical: Key setup failed, cannot proceed with chat.");
                // Optionally redirect or disable chat features
                // window.location.href = "/";
                return;
            }

            try {
                const joinResp = await fetch("/chat/join-chat/", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Token " + token
                    },
                    body: JSON.stringify({ chat_id: chatId })
                });

                if (!joinResp.ok) {
                    const errJson = await joinResp.json().catch(() => ({}));
                    alert(errJson.message || "Failed to join chat.");
                    window.location.href = "/";
                    return;
                }
            } catch (err) {
                console.error("Join-chat network error:", err);
                alert("Network error while joining chat.");
                window.location.href = "/";
                return;
            }

            pollInterval = setInterval(checkChatReady, 2000);
            await checkChatReady(); // Initial check immediately
        }

        async function checkChatReady() {
            try {
                const resp = await fetch(`/chat/get-messages/${chatId}/`, {
                    method: "GET",
                    headers: {
                        "Authorization": "Token " + token,
                    }
                });

                if (resp.status === 204) { // No Content, chat not ready or no new messages
                    return;
                }
                if (resp.status === 404) {
                    alert("Chat not found or your partner left before joining.");
                    localStorage.clear();
                    clearInterval(pollInterval);
                    window.location.href = "/";
                    return;
                }
                if (resp.status === 403) {
                    alert("You’re not authorized for this chat.");
                    clearInterval(pollInterval);
                    window.location.href = "/";
                    return;
                }
                if (!resp.ok) { // Other HTTP errors
                    console.error("checkChatReady() failed with status:", resp.status, await resp.text());
                    return;
                }

                const data = await resp.json();

                // 1) Hide the overlay and show chat right away if both joined
                if (data.both_joined) {
                    waitingOverlay.style.display = "none";
                    chatContainer.style.display = "flex";

                    // 2) Store partner_id so send-message can use it
                    if (data.partner_id) {
                        localStorage.setItem("partner_id", data.partner_id);
                        await loadPartnerPublicKey(); // Load partner's public key once chat is ready
                    }


                    // 3) Update partner's name if needed
                    if (data.partner && data.partner !== partnerUsername) {
                        partnerUsername = data.partner;
                        partnerNameSpan.textContent = partnerUsername;
                        localStorage.setItem("partner", partnerUsername);
                    }

                    // 4) Render any existing messages
                    await renderMessages(data.messages, data.current_user);

                    // 5) Switch to polling only for new messages from now on
                    clearInterval(pollInterval);
                    pollInterval = setInterval(fetchNewMessages, 2000);
                }
            } catch (err) {
                console.error("Error during checkChatReady:", err);
                // Consider showing a user-friendly error message or attempting to reconnect
            }
        }

        async function fetchNewMessages() {
            try {
                const resp = await fetch("/chat/get-messages/" + chatId + "/", {
                    headers: { "Authorization": "Token " + token }
                });
                if (!resp.ok) {
                    if (resp.status === 404 || resp.status === 403) {
                        alert("Chat ended or access revoked. Redirecting.");
                        localStorage.clear();
                        clearInterval(pollInterval);
                        window.location.href = "/";
                        return;
                    }
                    console.warn("fetchNewMessages got status", resp.status);
                    return;
                }

                const data = await resp.json();

                if (data.partner && data.partner !== partnerUsername) {
                    partnerUsername = data.partner;
                    partnerNameSpan.textContent = partnerUsername;
                    localStorage.setItem("partner", partnerUsername);
                    // Reload partner's public key if partner changes (unlikely in a 1:1 chat)
                    await loadPartnerPublicKey();
                }

                await renderMessages(data.messages, data.current_user);
            } catch (err) {
                console.error("Error fetching new messages:", err);
            }
        }

        async function renderMessages(messages, currentUserUsername) {
            // Clear only if needed (e.g., if re-rendering all messages)
            messagesDiv.innerHTML = "";

            for (const msg of messages) {
                await renderProcessedMessage(msg, currentUserUsername);
            }

            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        async function renderProcessedMessage(msg, currentUserUsername) {
            const isCurrentUser = (msg.sender_username === currentUserUsername);

            const div = document.createElement("div");
            div.className = isCurrentUser ? "sent" : "received";

            const usernameEl = document.createElement('div');
            usernameEl.className = 'message-username';
            usernameEl.textContent = isCurrentUser ? 'You' : msg.sender_username;

            const textEl = document.createElement('div');
            const timeEl = document.createElement('div');
            timeEl.className = 'message-time';
            timeEl.textContent = new Date(msg.timestamp).toLocaleTimeString();

            let displayContent = "";
            let signatureStatus = "";

            // Attempt decryption
            if (myEncryptionKeys && myEncryptionKeys.privateKey && msg.encrypted_symmetric_key && msg.encrypted_text && msg.aes_nonce && msg.aes_tag) {
                try {
                    // Decrypt AES key with our RSA private key
                    const encryptedAESKeyBuffer = base64ToArrayBuffer(msg.encrypted_symmetric_key);
                    const aesKeyBuffer = await window.crypto.subtle.decrypt(
                        { name: "RSA-OAEP" },
                        myEncryptionKeys.privateKey,
                        encryptedAESKeyBuffer
                    );

                    // Decrypt message content with AES key
                    const aesData = {
                        ciphertext: msg.encrypted_text,
                        nonce: msg.aes_nonce,
                        tag: msg.aes_tag
                    };
                    displayContent = await decryptWithAES(new Uint8Array(aesKeyBuffer), aesData);

                } catch (decryptError) {
                    console.error("Decryption failed for message:", msg.id, decryptError);
                    displayContent = "🔐 Unable to decrypt message.";
                }
            } else {
                displayContent = "⚠️ Message not fully encrypted/keys missing."; // Fallback if data is incomplete
            }

            // Attempt signature verification
            if (msg.signature && msg.sender_public_key && displayContent !== "🔐 Unable to decrypt message." && mySigningKeys && mySigningKeys.publicKey) {
                try {
                    const senderPubKey = await importRsaPublicKeyForVerify(msg.sender_public_key);
                    const signatureBuffer = base64ToArrayBuffer(msg.signature);

                    const isValidSignature = await window.crypto.subtle.verify(
                        { name: "RSA-PSS", saltLength: 32 }, // SaltLength must match signing
                        senderPubKey,
                        signatureBuffer,
                        new TextEncoder().encode(displayContent) // Signatures are over plaintext
                    );

                    signatureStatus = isValidSignature ? " ✓" : " ⚠️ Invalid Signature!";
                } catch (verifyError) {
                    console.error("Signature verification failed for message:", msg.id, verifyError);
                    signatureStatus = " ❓ Signature Error";
                }
            } else if (msg.signature && !msg.sender_public_key) {
                signatureStatus = " ❓ Sender public key missing for verification.";
            }

            textEl.textContent = `${displayContent}${signatureStatus}`;

            div.appendChild(usernameEl);
            div.appendChild(textEl);
            div.appendChild(timeEl);
            messagesDiv.appendChild(div);
        }

        // --- Message Sending Logic ---
        messageForm.addEventListener("submit", async function(e) {
            e.preventDefault();
            const plaintext = messageInput.value.trim();
            if (!plaintext) return;

            // Add console logs here to check the state of keys
            console.log("myEncryptionKeys:", myEncryptionKeys);
            console.log("mySigningKeys:", mySigningKeys);
            console.log("partnerPublicKey:", partnerPublicKey);


            if (!myEncryptionKeys || !myEncryptionKeys.publicKey) {
                showError("Encryption keys not loaded. Cannot send encrypted messages.");
                return;
            }
            if (!mySigningKeys || !mySigningKeys.privateKey) {
                showError("Signing key not loaded. Cannot sign messages.");
                return;
            }
            if (!partnerPublicKey) {
                showError("Partner's public key not loaded. Cannot encrypt messages.");
                return;
            }

            try {
                // 1) Generate AES key and encrypt the message with it
                const aesKey = generateAESKey();
                const aesEncrypted = await encryptWithAES(aesKey, plaintext);

                // 2) Encrypt the AES key with partner's RSA-OAEP public key
                const encryptedAESKey = await window.crypto.subtle.encrypt(
                    { name: "RSA-OAEP" },
                    partnerPublicKey, // Use the partner's loaded public key
                    aesKey
                );

                // 3) Sign the plaintext message (using our RSA-PSS private key)
                const signatureBuffer = await window.crypto.subtle.sign(
                    { name: "RSA-PSS", saltLength: 32 }, // SaltLength must match during verification
                    mySigningKeys.privateKey, // Use our stored RSA-PSS private key
                    new TextEncoder().encode(plaintext)
                );

                // 4) Base64-encode everything for transport
                const encryptedAESKeyB64 = arrayBufferToBase64(encryptedAESKey);
                const sigB64 = arrayBufferToBase64(signatureBuffer);

                // 5) POST to /chat/send-message/{chatId}/ with hybrid encryption data
                const sendResp = await fetch("/chat/send-message/" + chatId + "/", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Token " + token
                    },
                    body: JSON.stringify({
                        encrypted_text: aesEncrypted.ciphertext,
                        encrypted_symmetric_key: encryptedAESKeyB64,
                        aes_nonce: aesEncrypted.nonce,
                        aes_tag: aesEncrypted.tag,
                        signature: sigB64
                    })
                });

                if (sendResp.ok) {
                    messageInput.value = "";
                    // Immediately fetch new messages to show our sent message and any received ones
                    await fetchNewMessages();
                } else {
                    const errorData = await sendResp.json().catch(() => ({ message: "Unknown error" }));
                    showError(`Failed to send message: ${errorData.message || sendResp.statusText}`);
                }
            } catch (sendError) {
                console.error("Send message error:", sendError);
                showError("Failed to send message due to a cryptographic error.");
            }
        });

        // --- Leave Chat Functionality ---
        leaveButton.addEventListener("click", async function() {
            if (confirm("Are you sure you want to leave this chat?")) {
                await leaveChat();
            }
        });

        async function leaveChat() {
            try {
                // Note: Django `LeaveChatView` expects chat_id in body for POST,
                // but the old frontend sent it in URL. Check your Django urls.py and views.py.
                // Assuming it expects it in the body now:
                const resp = await fetch("/chat/leave-chat/", { // Adjusted endpoint based on your backend logic
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Token " + token
                    },
                    body: JSON.stringify({ chat_id: chatId }) // Sending chat_id in body
                });

                if (!resp.ok) {
                    console.warn("Server responded with error while leaving chat:", resp.status, await resp.text());
                }
            } catch (err) {
                console.error("Error leaving chat:", err);
            } finally {
                localStorage.removeItem('chat_id'); // Clear local chat state
                localStorage.removeItem('partner');
                localStorage.removeItem('partner_id');
                clearInterval(pollInterval);
                window.location.href = "/"; // Redirect to home/login page
            }
        }

        // Handle page unload (attempt to leave chat gracefully)
        window.addEventListener("beforeunload", async function(event) {
            if (pollInterval) {
                clearInterval(pollInterval);
            }
            // Note: Sending an async request on beforeunload can be unreliable
            // Browsers may cancel it if the page unloads too quickly.
            // A small delay or synchronous call (not recommended for UX) might be needed for critical actions.
            // For now, keep it as is, but be aware.
            if (chatId && token) { // Only attempt if user is in an active chat
                navigator.sendBeacon("/chat/leave-chat/", JSON.stringify({ chat_id: chatId }));
                // sendBeacon is better for unload events as it doesn't block the main thread.
                // It requires the backend to handle application/json for sendBeacon.
            }
        });


        // --- Initial Call to Start the Application ---
        startChat();
    })();
</script>
</body>
</html>