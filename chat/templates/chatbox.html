<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8" />
    <title>Secure Chat • Live</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" />

    <style>
        :root {
            --bg-primary: #0a0a1f;
            --bg-secondary: #121229;
            --sent-bg: #00e5ff;
            --recv-bg: #1e1e2e;
            --accent-magenta: #ff0080;
            --text-main: #e0e0ff;
            --text-secondary: #8888aa;
            --timestamp-text: #999;
            --glow-small: 0 0 6px var(--sent-bg);
            --transition: 0.2s ease;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: var(--bg-primary);
            font-family: 'Orbitron', sans-serif;
            color: var(--text-main);
            display: flex; flex-direction: column; height: 100vh; overflow: hidden;
        }

        header#chat-header {
            background: var(--bg-secondary);
            padding: 1rem 1.5rem;
            display: flex; justify-content: space-between; align-items: center;
            box-shadow: var(--glow-small);
            border-bottom: 2px solid var(--sent-bg);
            z-index: 10;
        }
        .chat-title { font-size: 1.4rem; color: var(--sent-bg); text-shadow: var(--glow-small); display: flex; align-items: center; }
        .chat-title i { margin-right: 0.5rem; }
        .account-btn { background: transparent; border: 1px solid var(--sent-bg); border-radius: 6px; padding: 0.5rem 0.75rem; color: var(--sent-bg); font-size: 0.9rem; display: inline-flex; align-items: center; text-decoration: none; transition: var(--transition); }
        .account-btn i { margin-right: 0.4rem; }
        .account-btn:hover { background: rgba(0,229,255,0.1); }

        #chatContainer { flex: 1; display: flex; flex-direction: column; height: calc(100vh - 68px); }
        #messages { flex: 1; padding: 1.5rem; overflow-y: auto; display: flex; flex-direction: column; gap: 1rem; }

        .message {
            max-width: 75%; padding: 0.75rem 1rem; font-size: 0.95rem; display: flex; flex-direction: column; gap: 0.5rem; word-wrap: break-word; position: relative;
        }
        .message-header { display: flex; justify-content: space-between; align-items: center; }
        .message-username { font-weight: bold; font-size: 0.85rem; color: var(--text-secondary); }
        .message-timestamp { font-size: 0.7rem; color: var(--timestamp-text); }

        /* Sent messages */
        .message.current-user {
            align-self: flex-end;
            background: var(--sent-bg);
            color: #000;
            border-radius: 16px 16px 4px 16px;
            box-shadow: var(--glow-small), 0 1px 3px rgba(0,0,0,0.2);
        }
        .message.current-user::after {
            content: "";
            position: absolute; top: 12px; right: -8px; width: 0; height: 0;
            border-top: 8px solid transparent;
            border-left: 8px solid var(--sent-bg);
            border-bottom: 8px solid transparent;
        }

        /* Received messages */
        .message.other-user {
            align-self: flex-start;
            background: var(--recv-bg);
            color: var(--text-main);
            border: 1px solid var(--sent-bg);
            border-radius: 16px 16px 16px 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .message.other-user::before {
            content: "";
            position: absolute; top: 12px; left: -8px; width: 0; height: 0;
            border-top: 8px solid transparent;
            border-right: 8px solid var(--recv-bg);
            border-bottom: 8px solid transparent;
        }

        #message-form { display: flex; padding: 1rem; background: var(--bg-secondary); border-top: 2px solid var(--sent-bg); }
        #message-input { flex:1; padding:0.75rem 1rem; border:1px solid var(--sent-bg); border-radius:50px; background:var(--bg-primary); color:var(--text-main); font-size:1rem; box-shadow:inset 0 0 5px rgba(0,0,0,0.5); transition:var(--transition); }
        #message-input:focus { outline:none; border-color:var(--accent-magenta); }
        #message-form button { margin-left:0.75rem; background:var(--accent-magenta); border-radius:50px; padding:0 1.2rem; cursor:pointer; display:flex; align-items:center; font-weight:bold; text-transform:uppercase; box-shadow:var(--glow-small); transition:var(--transition); color:#000; border:none; }
        #message-form button:hover { transform:scale(1.05); }
        #leave-chat { width:100%; padding:0.9rem; background:#ff0044; border:none; color:#fff; text-transform:uppercase; letter-spacing:0.5px; transition:var(--transition); cursor:pointer; }
        #leave-chat:hover { background:#e6003d; }
        .error-message { background:rgba(255,0,68,0.1); border:1px solid #ff0044; color:#ff6b6b; padding:0.75rem; border-radius:8px; margin:0.5rem; text-align:center; }
    </style>
</head>
<body>
<div id="waitingOverlay">
    <div class="box">
        <p>Waiting for the other user to join…</p>
    </div>
</div>
<header id="chat-header">
    <div class="chat-title">
        <i class="fas fa-comments"></i>
        Talking with- <span id="partner-name">…</span>
    </div>
    <a href="/chat/usermenu/" class="account-btn">
        <i class="fas fa-user-circle"></i> Account
    </a>
</header>
<div id="chatContainer" style="display:none;">
    <div id="messages"></div>
    <form id="message-form">
        <input type="text" id="message-input" placeholder="Type your message..." required />
        <button type="submit">Send <i class="fas fa-paper-plane"></i></button>
    </form>
    <button id="leave-chat"><i class="fas fa-sign-out-alt"></i> Leave Chat</button>
</div>

<script>
    (async function() {
        // Local Storage Keys
        const STORAGE_PRIV = "private_key_pem"; // RSA-OAEP private key for decryption
        const STORAGE_PUB = "public_key_pem";   // RSA-OAEP public key for encryption by others
        const STORAGE_SIGN_PRIV = "signing_private_key_pem"; // RSA-PSS private key for signing
        const STORAGE_SIGN_PUB = "signing_public_key_pem"; // RSA-PSS public key for signature verification by others

        const uploadEndpoint = "/chat/upload-public-key/"; // Endpoint for uploading RSA-OAEP public key

        function derToPem(derBuffer, label) {
            const bytes = new Uint8Array(derBuffer);
            let b64 = "";
            for (let i = 0; i < bytes.byteLength; i++) {
                b64 += String.fromCharCode(bytes[i]);
            }
            const b64lines = window.btoa(b64).match(/.{1,64}/g).join("\n");
            return `-----BEGIN ${label}-----\n${b64lines}\n-----END ${label}-----`;
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = "";
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        function base64ToArrayBuffer(b64) {
            const binary = window.atob(b64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }


        function generateAESKey() {
            return window.crypto.getRandomValues(new Uint8Array(32)); // AES-256 key
        }

        // AES-GCM encryption
        async function encryptWithAES(key, plaintext) {
            const iv = window.crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV recommended for AES-GCM
            const algorithm = { name: 'AES-GCM', iv: iv };

            const cryptoKey = await window.crypto.subtle.importKey(
                'raw',
                key,
                { name: 'AES-GCM' },
                false, // not extractable
                ['encrypt']
            );

            const encrypted = await window.crypto.subtle.encrypt(
                algorithm,
                cryptoKey,
                new TextEncoder().encode(plaintext)
            );

            // AES-GCM encrypted output is ciphertext + authentication tag.
            // The tag is usually the last 16 bytes.
            const ciphertext = encrypted.slice(0, encrypted.byteLength - 16);
            const tag = encrypted.slice(encrypted.byteLength - 16);

            return {
                ciphertext: arrayBufferToBase64(ciphertext),
                nonce: arrayBufferToBase64(iv),
                tag: arrayBufferToBase64(tag)
            };
        }

        // AES-GCM decryption
        async function decryptWithAES(key, data) {
            const ciphertext = base64ToArrayBuffer(data.ciphertext);
            const nonce = base64ToArrayBuffer(data.nonce);
            const tag = base64ToArrayBuffer(data.tag);

            // Combine ciphertext and tag for decryption
            const combined = new Uint8Array(ciphertext.byteLength + tag.byteLength);
            combined.set(new Uint8Array(ciphertext));
            combined.set(new Uint8Array(tag), ciphertext.byteLength);

            const algorithm = { name: 'AES-GCM', iv: nonce };

            const cryptoKey = await window.crypto.subtle.importKey(
                'raw',
                key,
                { name: 'AES-GCM' },
                false, // not extractable
                ['decrypt']
            );

            const decrypted = await window.crypto.subtle.decrypt(
                algorithm,
                cryptoKey,
                combined
            );

            return new TextDecoder().decode(decrypted);
        }

        // Import RSA Public Key for Encryption (OAEP)
        async function importRsaPublicKeyForEncrypt(pem) {
            const b64 = pem.replace(/-----.*?-----|[\n\r]/g, ""); // Remove PEM headers and newlines
            const der = Uint8Array.from(window.atob(b64), c => c.charCodeAt(0)).buffer;
            return await window.crypto.subtle.importKey(
                "spki", // SubjectPublicKeyInfo format
                der,
                { name: "RSA-OAEP", hash: "SHA-256" },
                true, // extractable
                ["encrypt"]
            );
        }

        // Import RSA Private Key for Decryption (OAEP)
        async function importRsaPrivateKeyForDecrypt(pem) {
            const b64 = pem.replace(/-----.*?-----|[\n\r]/g, "");
            const der = Uint8Array.from(window.atob(b64), c => c.charCodeAt(0)).buffer;
            return await window.crypto.subtle.importKey(
                "pkcs8", // PrivateKeyInfo format
                der,
                { name: "RSA-OAEP", hash: "SHA-256" },
                true, // extractable
                ["decrypt"]
            );
        }

        // Import RSA Private Key for Signing (PSS)
        async function importRsaPrivateKeyForSign(pem) {
            const b64 = pem.replace(/-----.*?-----|[\n\r]/g, "");
            const der = Uint8Array.from(window.atob(b64), c => c.charCodeAt(0)).buffer;
            return await window.crypto.subtle.importKey(
                "pkcs8", // PrivateKeyInfo format
                der,
                { name: "RSA-PSS", hash: "SHA-256" },
                true, // extractable
                ["sign"]
            );
        }

        // Import RSA Public Key for Verification (PSS)
        async function importRsaPublicKeyForVerify(pem) {
            const b64 = pem.replace(/-----.*?-----|[\n\r]/g, "");
            const der = Uint8Array.from(window.atob(b64), c => c.charCodeAt(0)).buffer;
            return await window.crypto.subtle.importKey(
                "spki", // SubjectPublicKeyInfo format
                der,
                { name: "RSA-PSS", hash: "SHA-256" },
                true, // extractable
                ["verify"]
            );
        }

        let myEncryptionKeys; // Will store imported RSA-OAEP keys
        let mySigningKeys;    // Will store imported RSA-PSS keys
        let partnerPublicKey=null;
        let partnerSigningKey = null;

        async function loadAndGenerateKeys() {
            let privPem = localStorage.getItem(STORAGE_PRIV);
            let pubPem = localStorage.getItem(STORAGE_PUB);
            let signPrivPem = localStorage.getItem(STORAGE_SIGN_PRIV);
            let signPubPem = localStorage.getItem(STORAGE_SIGN_PUB);

            // If any critical key is missing, generate all new pairs
            if (!privPem || !pubPem || !signPrivPem || !signPubPem) {
                console.log("No keys found — generating fresh RSA-OAEP & RSA-PSS keypairs…");
                try {
                    console.log("Generating RSA-OAEP keypair for encryption…");
                    const encKeyPair = await window.crypto.subtle.generateKey(
                        {
                            name: "RSA-OAEP",
                            modulusLength: 2048,
                            publicExponent: new Uint8Array([1, 0, 1]), // 65537
                            hash: "SHA-256"
                        },
                        true, // extractable
                        ["encrypt", "decrypt"]
                    );
                    const encPrivDer = await window.crypto.subtle.exportKey("pkcs8", encKeyPair.privateKey);
                    privPem = derToPem(encPrivDer, "PRIVATE KEY");
                    localStorage.setItem(STORAGE_PRIV, privPem);
                    const encPubDer = await window.crypto.subtle.exportKey("spki", encKeyPair.publicKey);
                    pubPem = derToPem(encPubDer, "PUBLIC KEY");
                    localStorage.setItem(STORAGE_PUB, pubPem);
                    myEncryptionKeys = { privateKey: encKeyPair.privateKey, publicKey: encKeyPair.publicKey };

                    // RSA-PSS Key Pair (for Digital Signatures)
                    console.log("Generating RSA-PSS keypair for signing…");
                    const signKeyPair = await window.crypto.subtle.generateKey(
                        {
                            name: "RSA-PSS",
                            modulusLength: 2048,
                            publicExponent: new Uint8Array([1, 0, 1]), // 65537
                            hash: "SHA-256"
                        },
                        true, // extractable
                        ["sign", "verify"]
                    );
                    const signPrivDer = await window.crypto.subtle.exportKey("pkcs8", signKeyPair.privateKey);
                    signPrivPem = derToPem(signPrivDer, "PRIVATE KEY");
                    localStorage.setItem(STORAGE_SIGN_PRIV, signPrivPem);
                    const signPubDer = await window.crypto.subtle.exportKey("spki", signKeyPair.publicKey);
                    signPubPem = derToPem(signPubDer, "PUBLIC KEY");
                    localStorage.setItem(STORAGE_SIGN_PUB, signPubPem);
                    mySigningKeys = { privateKey: signKeyPair.privateKey, publicKey: signKeyPair.publicKey };

                    // Upload the RSA-OAEP public key to the server
                    const token = localStorage.getItem("token");
                    if (token) {
                        console.log("Public key generated; uploading to server now…");
                        const resp = await fetch(uploadEndpoint, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "Authorization": "Token " + token
                            },
                            body: JSON.stringify({
                                public_key: pubPem,
                                signing_public_key: signPubPem
                                })
                        });
                        if (!resp.ok) {
                            console.warn("Could not upload public key:", await resp.text());
                            showError("Failed to upload encryption public key.");
                        } else {
                            console.log("Server confirmed: public key saved successfully.");
                        }
                    } else {
                        console.warn("No token found, cannot upload public key.");
                    }

                } catch (err) {
                    console.error("Key‐generation/upload failed:", err);
                    showError("Failed to generate or upload keys.");
                    throw err;
                }
            } else {
                console.log("Loading existing RSA key pairs...");
                // Import existing keys
                try {
                    myEncryptionKeys = {
                        privateKey: await importRsaPrivateKeyForDecrypt(privPem),
                        publicKey: await importRsaPublicKeyForEncrypt(pubPem)
                    };
                    mySigningKeys = {
                        privateKey: await importRsaPrivateKeyForSign(signPrivPem),
                        publicKey: await importRsaPublicKeyForVerify(signPubPem)
                    };
                } catch (err) {
                    console.error("Error importing stored RSA key pairs:", err);
                    showError("Failed to load encryption keys (messages may be unencrypted). Please clear local storage and try again.");
                    throw err; // Re-throw to signify a problem
                }
            }
        }

        function pemToArrayBuffer(pem) {
            const b64 = pem
                .replace(/-----BEGIN PUBLIC KEY-----/, '')
                .replace(/-----END PUBLIC KEY-----/, '')
                .replace(/\s+/g, '');
            const binary = atob(b64);
            const len = binary.length;
            const buf = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                buf[i] = binary.charCodeAt(i);
            }
            return buf.buffer;
        }

        async function loadPartnerPublicKey() {
            const partnerId = localStorage.getItem('partner_id');
            if (!partnerId) {
                throw new Error('No partner_id in localStorage');
            }

            const token = localStorage.getItem('token');
            const resp = await fetch(`/chat/get-public-key/${partnerId}/`, {
                headers: { 'Authorization': 'Token ' + token }
            });
            if (!resp.ok) {
                throw new Error(`Could not fetch public key: ${resp.status}`);
            }

            const {
                public_key: pem,
                signing_public_key: signPem
            } = await resp.json();


            // import the PEM key into a CryptoKey
            const keyBuffer = pemToArrayBuffer(pem);
            partnerPublicKey = await window.crypto.subtle.importKey(
                'spki',
                keyBuffer,
                { name: 'RSA-OAEP', hash: 'SHA-256' },
                false,
                ['encrypt']
            );
            // ← SIGNING: import RSA-PSS public key for verify
            partnerSigningKey = await importRsaPublicKeyForVerify(signPem);

            // optionally cache the raw PEM in localStorage
            localStorage.setItem('partner_public_key', pem);
        }

        async function sendMessage() {
            if (!partnerPublicKey) {
                await loadPartnerPublicKey();
            }

            // now you can encrypt:
            const encoder = new TextEncoder();
            const data = encoder.encode(messageText);
            const ciphertext = await window.crypto.subtle.encrypt(
                { name: 'RSA-OAEP' },
                partnerPublicKey,
                data
            );
            // … send ciphertext to /chat/send-message/ …
        }

        //DOM Elements
        const messagesDiv = document.getElementById("messages");
        const partnerNameSpan = document.getElementById("partner-name");
        const messageForm = document.getElementById("message-form");
        const messageInput = document.getElementById("message-input");
        const waitingOverlay = document.getElementById("waitingOverlay");
        const chatContainer = document.getElementById("chatContainer");
        const leaveButton = document.getElementById("leave-chat");

        //Chat Variables
        const chatId = localStorage.getItem("chat_id");
        const token = localStorage.getItem("token");
        let partnerUsername = localStorage.getItem("partner") || "…";
        let pollInterval = null;

        // UI Functions
        function showError(message) {
            const errorDiv = document.createElement("div");
            errorDiv.className = "error-message";
            errorDiv.textContent = message;
            messagesDiv.appendChild(errorDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        //Main Chat Logic
        async function startChat() {
            if (!chatId || !token) {
                alert("Missing chat ID or authentication token. Redirecting to home.");
                window.location.href = "/";
                return;
            }

            try {
                await loadAndGenerateKeys(); // Load or generate our own keys first
            } catch (e) {
                // Key generation/load failed, user is already alerted by showError
                console.error("Critical: Key setup failed, cannot proceed with chat.");
                // Optionally redirect or disable chat features
                // window.location.href = "/";
                return;
            }

            try {
                const joinResp = await fetch("/chat/join-chat/", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Token " + token
                    },
                    body: JSON.stringify({ chat_id: chatId })
                });

                if (!joinResp.ok) {
                    const errJson = await joinResp.json().catch(() => ({}));
                    alert(errJson.message || "Failed to join chat.");
                    window.location.href = "/";
                    return;
                }
            } catch (err) {
                console.error("Join-chat network error:", err);
                alert("Network error while joining chat.");
                window.location.href = "/";
                return;
            }

            pollInterval = setInterval(checkChatReady, 2000);
            await checkChatReady(); // Initial check immediately
        }

        async function checkChatReady() {
            try {
                const resp = await fetch(`/chat/get-messages/${chatId}/`, {
                    method: "GET",
                    headers: {
                        "Authorization": "Token " + token,
                    }
                });

                if (resp.status === 204) { // No Content, chat not ready or no new messages
                    return;
                }
                if (resp.status === 404) {
                    alert("Chat not found or your partner left before joining.");
                    localStorage.clear();
                    clearInterval(pollInterval);
                    window.location.href = "/";
                    return;
                }
                if (resp.status === 403) {
                    alert("You’re not authorized for this chat.");
                    clearInterval(pollInterval);
                    window.location.href = "/";
                    return;
                }
                if (!resp.ok) { // Other HTTP errors
                    console.error("checkChatReady() failed with status:", resp.status, await resp.text());
                    return;
                }

                const data = await resp.json();

                // 1) Hide the overlay and show chat right away if both joined
                if (data.both_joined) {
                    waitingOverlay.style.display = "none";
                    chatContainer.style.display = "flex";

                    // 2) Store partner_id so send-message can use it
                    if (data.partner_id) {
                        localStorage.setItem("partner_id", data.partner_id);
                        await loadPartnerPublicKey(); // Load partner's public key once chat is ready
                    }


                    // 3) Update partner's name if needed
                    if (data.partner && data.partner !== partnerUsername) {
                        partnerUsername = data.partner;
                        partnerNameSpan.textContent = partnerUsername;
                        localStorage.setItem("partner", partnerUsername);
                    }

                    // 4) Render any existing messages
                    await renderMessages(data.messages, data.current_user);

                    // 5) Switch to polling only for new messages from now on
                    clearInterval(pollInterval);
                    pollInterval = setInterval(fetchNewMessages, 2000);
                }
            } catch (err) {
                console.error("Error during checkChatReady:", err);
                // Consider showing a user-friendly error message or attempting to reconnect
            }
        }

        async function fetchNewMessages() {
            try {
                const resp = await fetch("/chat/get-messages/" + chatId + "/", {
                    headers: { "Authorization": "Token " + token }
                });
                if (!resp.ok) {
                    if (resp.status === 404 || resp.status === 403) {
                        alert("Chat ended or access revoked. Redirecting.");
                        localStorage.clear();
                        clearInterval(pollInterval);
                        window.location.href = "/";
                        return;
                    }
                    console.warn("fetchNewMessages got status", resp.status);
                    return;
                }

                const data = await resp.json();
                console.log(" fetched messages:", data.messages);
                //data.messages.forEach(msg => renderProcessedMessage(msg, data.current_user));

                if (data.partner && data.partner !== partnerUsername) {
                    partnerUsername = data.partner;
                    partnerNameSpan.textContent = partnerUsername;
                    localStorage.setItem("partner", partnerUsername);
                    // Reload partner's public key if partner changes (unlikely in a 1:1 chat)
                    await loadPartnerPublicKey();
                }

                await renderMessages(data.messages, data.current_user);
            } catch (err) {
                console.error("Error fetching new messages:", err);
            }
        }

        async function renderMessages(messages, currentUserUsername) {
            // Clear only if needed (e.g., if re-rendering all messages)
            messagesDiv.innerHTML = "";

            for (const msg of messages) {
                await renderProcessedMessage(msg, currentUserUsername);
            }

            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        async function renderProcessedMessage(msg, currentUserUsername) {
            const isCurrentUser = msg.sender_username === currentUserUsername;
            const bubble = document.createElement("div");
            bubble.classList.add("message", isCurrentUser ? "current-user" : "other-user");

            // Header row
            const header = document.createElement("div");
            header.className = "message-header";
            const userEl = document.createElement("div");
            userEl.className = "message-username";
            userEl.textContent = isCurrentUser ? "You" : msg.sender_username;
            const timeEl = document.createElement("div");
            timeEl.className = "message-timestamp";
            timeEl.textContent = new Date(msg.timestamp).toLocaleTimeString();
            header.append(userEl, timeEl);

            let displayContent = "";
            try {
                // 1) Pick the right wrapped key — new field first, then fallback
                const wrappedKeyB64 = isCurrentUser
                    ? (msg.sender_encrypted_symmetric_key || msg.encrypted_symmetric_key)
                    : msg.encrypted_symmetric_key;
                if (!wrappedKeyB64) throw new Error("No wrapped AES key available");

                // 2) RSA-OAEP unwrap with *your* private key
                const aesKeyBuf = await window.crypto.subtle.decrypt(
                    { name: "RSA-OAEP" },
                    myEncryptionKeys.privateKey,
                    base64ToArrayBuffer(wrappedKeyB64)
                );

                // 3) AES-GCM decrypt
                displayContent = await decryptWithAES(new Uint8Array(aesKeyBuf), {
                    ciphertext: msg.encrypted_text,
                    nonce:      msg.aes_nonce,
                    tag:        msg.aes_tag
                });
            } catch (e) {
                console.warn("Could not decrypt message", msg.id, e);
                return;  // skip it
            }

            // render
            const textEl = document.createElement("div");
            textEl.textContent = displayContent;
            bubble.append(header, textEl);
            messagesDiv.appendChild(bubble);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }


        // --- Message Sending Logic ---
        messageForm.addEventListener("submit", async function(e) {
            e.preventDefault();
            const plaintext = messageInput.value.trim();
            if (!plaintext) return;

            // sanity checks
            if (!myEncryptionKeys?.publicKey) {
                showError("Encryption keys not loaded. Cannot send encrypted messages.");
                return;
            }
            if (!mySigningKeys?.privateKey) {
                showError("Signing key not loaded. Cannot sign messages.");
                return;
            }
            if (!partnerPublicKey) {
                showError("Partner's public key not loaded. Cannot encrypt messages.");
                return;
            }

            try {
                // 1) Generate AES key and encrypt the message with it
                const aesKey = generateAESKey();
                const aesEncrypted = await encryptWithAES(aesKey, plaintext);
                //    -> { ciphertext, nonce, tag }

                // 2a) Wrap the AES key for the partner
                const wrappedForPartner = await window.crypto.subtle.encrypt(
                    { name: "RSA-OAEP" },
                    partnerPublicKey,
                    aesKey
                );
                // 2b) Wrap the AES key for yourself
                const wrappedForSelf = await window.crypto.subtle.encrypt(
                    { name: "RSA-OAEP" },
                    myEncryptionKeys.publicKey,
                    aesKey
                );

                // 3) Sign the plaintext message (RSA-PSS)
                const signatureBuffer = await window.crypto.subtle.sign(
                    { name: "RSA-PSS", saltLength: 32 },
                    mySigningKeys.privateKey,
                    new TextEncoder().encode(plaintext)
                );

                // 4) Base64-encode everything for transport
                const partnerKeyB64 = arrayBufferToBase64(wrappedForPartner);
                const selfKeyB64    = arrayBufferToBase64(wrappedForSelf);
                const sigB64        = arrayBufferToBase64(signatureBuffer);

                // 5) POST to /chat/send-message/{chatId}/ with both wrapped keys
                const sendResp = await fetch(`/chat/send-message/${chatId}/`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Token " + token
                    },
                    body: JSON.stringify({
                        encrypted_text:                 aesEncrypted.ciphertext,
                        encrypted_symmetric_key:        partnerKeyB64,  // for recipient
                        sender_encrypted_symmetric_key: selfKeyB64,     // for you
                        aes_nonce:                      aesEncrypted.nonce,
                        aes_tag:                        aesEncrypted.tag,
                        signature:                      sigB64
                    })
                });

                if (sendResp.ok) {
                    // Clear input
                    messageInput.value = "";
                    // Immediately refresh so you’ll see both your bubble and any new incoming ones
                    await fetchNewMessages();
                } else {
                    const errorData = await sendResp.json().catch(() => ({}));
                    showError(`Failed to send message: ${errorData.message || sendResp.statusText}`);
                }
            } catch (err) {
                console.error("Send message error:", err);
                showError("Failed to send message due to a cryptographic error.");
            }
        });

        // --- Leave Chat Functionality ---
        leaveButton.addEventListener("click", async function() {
            if (confirm("Are you sure you want to leave this chat?")) {
                await leaveChat();
            }
        });

        async function leaveChat() {
            try {
                // Note: Django `LeaveChatView` expects chat_id in body for POST,
                // but the old frontend sent it in URL. Check your Django urls.py and views.py.
                // Assuming it expects it in the body now:
                const resp = await fetch("/chat/leave-chat/", { // Adjusted endpoint based on your backend logic
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Token " + token
                    },
                    body: JSON.stringify({ chat_id: chatId }) // Sending chat_id in body
                });

                if (!resp.ok) {
                    console.warn("Server responded with error while leaving chat:", resp.status, await resp.text());
                }
            } catch (err) {
                console.error("Error leaving chat:", err);
            } finally {
                localStorage.removeItem('chat_id'); // Clear local chat state
                localStorage.removeItem('partner');
                localStorage.removeItem('partner_id');
                clearInterval(pollInterval);
                window.location.href = "/"; // Redirect to home/login page
            }
        }

        // Handle page unload (attempt to leave chat gracefully)
        window.addEventListener("beforeunload", async function(event) {
            if (pollInterval) {
                clearInterval(pollInterval);
            }
            // Note: Sending an async request on beforeunload can be unreliable
            // Browsers may cancel it if the page unloads too quickly.
            // A small delay or synchronous call (not recommended for UX) might be needed for critical actions.
            // For now, keep it as is, but be aware.
            if (chatId && token) { // Only attempt if user is in an active chat
                navigator.sendBeacon("/chat/leave-chat/", JSON.stringify({ chat_id: chatId }));
                // sendBeacon is better for unload events as it doesn't block the main thread.
                // It requires the backend to handle application/json for sendBeacon.
            }
        });


        startChat();
    })();
</script>
</body>
</html>